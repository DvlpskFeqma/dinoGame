<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>純HTML小恐龍遊戲</title>
    <style>
        body { 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            height: 100vh; margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            transition: background-color 1s ease;
            overflow: hidden; /* 防止震動時出現捲軸 */
        }
        h1, p { 
            color: #555; 
            transition: color 1s ease;
        }
        canvas { 
            border: 2px solid #333;
            transition: border-color 1s ease;
            display: block; /* 解決canvas底部多餘的空間 */
        }
        #canvas-container.shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body>

    <h1>小恐龍遊戲</h1>
    <div id="canvas-container">
        <canvas id="gameCanvas" width="800" height="250"></canvas>
    </div>
    <p><strong>Z/C</strong>移動 | <strong>空白鍵</strong>跳躍 | <strong>X</strong>發射 (集滿可蓄力)</p>

    <script>
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dinoImage = new Image();
        dinoImage.src = 'dino.png';

        // --- 遊戲變數 ---
        let dino, gravity = 0.6, gameSpeed = 5, score = 0;
        let obstacles = [], fireballs = [], creatures = [], scorePopups = [], flyingEnemies = [], enemyBullets = [];
        let ultimateFireball = null;
        let gameOver = false, gameStarted = false, frameCount = 0;
        let nextObstacleFrame, nextCreatureFrame, nextFlyingEnemySpawn = 0;
        const keyState = {};
        let xPressStartTime = 0; // 新增變數，記錄X鍵按下的時間

        // 雷雨系統變數
        let thunderstormActive = false;
        let thunderstormStartTime = 0; // 記錄雷雨開始時間
        const thunderstormDuration = 30 * 60; // 雷雨持續30秒
        let lightningStrikeTimer = 0; // 雷雨期間閃電計時器
        const lightningStrikeInterval = 5 * 60; // 雷雨期間每5秒打一次雷
        let lightningMarks = []; // 儲存驚嘆號和天雷位置的陣列
        let rainParticles = []; // 儲存雨滴粒子的陣列

        // 新武器系統變數
        let hasNewWeapon = false;
        let newWeaponAmmo = 0; // 新武器的彈藥量
        const newWeaponMaxAmmo = 5; // 新武器的最大彈藥量
        let weaponDropTimer = 0;
        const weaponDropInterval = 5 * 60; // 每5秒掉落一次武器
        let weaponPickups = []; // 儲存武器掉落物的陣列

        // BOSS 系統變數
        let boss = null;
        let bossActive = false;
        const maxBossHealth = 20;
        let bossHealth = maxBossHealth;
        let bossShootTimer = 0;
        const bossShootInterval = 90; // BOSS 每 1.5 秒射擊一次 (90 幀)
        let bossSummonTimer = 0;
        const bossSummonInterval = 180; // BOSS 每 3 秒召喚一次 (180 幀)
        const bossMaxSummon = 3; // 連續召喚 3 個
        let bossDefeatedCount = 0; // 追蹤BOSS被擊敗的次數

        // 資源管理
        let maxFireballs = 10, currentFireballs = 10, fireballRegenRate = 120, fireballRegenCounter = 0;
        let maxHealth = 3, dinoHealth = 3, isInvincible = false, invincibilityDuration = 120, invincibilityCounter = 0;
        let isCharging = false, chargeTime = 0, minChargeTime = 30;

        // 日夜循環
        let timeInCycle = 0, transitionTime = 0, isDay = true;
        const dayDuration = 15 * 60, nightDuration = 30 * 60, transitionDuration = 60;
        const dayColors = { bg: '#ffffff', fg: '#555', ground: '#333' }, nightColors = { bg: '#2c3e50', fg: '#ecf0f1', ground: '#bdc3c7' }, thunderstormColors = { bg: '#000000', fg: '#aaaaaa', ground: '#555555' }; // 雷雨顏色
        let currentColors = { ...dayColors };

        function setNextObstacleFrame() { nextObstacleFrame = frameCount + Math.floor(Math.random() * 50 + 60); }
        function setNextCreatureFrame() { nextCreatureFrame = frameCount + Math.floor(Math.random() * 150 + 120); }

        // --- 類別定義 ---
        class ScorePopup{constructor(x,y,t){this.x=x;this.y=y;this.text=t;this.life=60;this.opacity=1;}update(){this.y-=0.5;this.life--;this.opacity=this.life/60;}draw(){ctx.save();ctx.globalAlpha=this.opacity;ctx.fillStyle='#28a745';ctx.font='16px Arial';ctx.fillText(this.text,this.x,this.y);ctx.restore();}}
        class Fireball{constructor(x,y){this.x=x;this.y=y;this.width=20;this.height=10;this.speed=10;}draw(){ctx.fillStyle='#ff4500';ctx.fillRect(this.x,this.y,this.width,this.height);}update(){this.x+=this.speed;this.draw();}}
        class UltimateFireball{constructor(x,y){this.x=x;this.y=y;this.w=50;this.h=canvas.height;this.speed=gameSpeed*1.5;}draw(){const grad=ctx.createLinearGradient(this.x,this.y,this.x+this.w,this.y);grad.addColorStop(0,'rgba(255,100,0,0.8)');grad.addColorStop(0.5,'rgba(255,255,0,0.8)');grad.addColorStop(1,'rgba(255,100,0,0.8)');ctx.fillStyle=grad;ctx.fillRect(this.x,this.y,this.w,this.h);}update(){this.x+=this.speed;this.draw();}}
        class Dino{
            constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h;this.dy=0;this.vx=0;this.moveSpeed=5;this.isJumping=false;this.jumpPower=-15;this.groundY=canvas.height-10;}
            draw(){if(isInvincible){if(invincibilityCounter%10<5){ctx.drawImage(dinoImage,this.x,this.y,this.w,this.h);}}else{ctx.drawImage(dinoImage,this.x,this.y,this.w,this.h);}}
            update(){
                this.handleMovement();
                this.x += this.vx;
                if(this.isJumping){this.dy+=gravity;this.y+=this.dy;}
                if(this.y+this.h>this.groundY){this.y=this.groundY-this.h;this.dy=0;this.isJumping=false;}
                if(this.x<0){this.x=0;}//左邊界
                if(this.x+this.w>canvas.width){this.x=canvas.width-this.w;}//右邊界
                this.draw();
            }
            handleMovement(){
                this.vx = 0;
                if(keyState['KeyZ']){ this.vx = -this.moveSpeed; }
                if(keyState['KeyC']){ this.vx = this.moveSpeed; }
            }
            jump(){if(!this.isJumping){this.isJumping=true;this.dy=this.jumpPower;}}
            cutJump() { if (this.dy < 0) { this.dy = 0; } }
            shoot(){
                if(currentFireballs>0){
                    if (hasNewWeapon) {
                        // 計算PurpleBall的初始速度
                        const initialVx = 5; // 基礎水平速度
                        const initialVy = -5; // 基礎向上速度（負值表示向上）
                        fireballs.push(new PurpleBall(this.x + this.w, this.y + this.h / 2 - 5, initialVx, initialVy));
                        newWeaponAmmo--; // 減少新武器彈藥
                        if (newWeaponAmmo <= 0) {
                            hasNewWeapon = false; // 彈藥用完後失去武器
                            currentFireballs = maxFireballs; // 重置火球為滿，恢復普通武器
                        }
                    } else {
                        fireballs.push(new Fireball(this.x+this.w,this.y+this.h/2-5));
                        currentFireballs--;
                    }
                }
            }
            fireUltimate(){
                if(chargeTime>=minChargeTime){
                    if (hasNewWeapon) {
                        // PurpleBall的蓄力射擊
                        const chargeMultiplier = chargeTime / minChargeTime; // 蓄力程度
                        const initialVx = 10 + (chargeMultiplier * 5); // 增加水平速度
                        const initialVy = -5 - (chargeMultiplier * 2); // 增加向上速度
                        fireballs.push(new PurpleBall(this.x + this.w, this.y + this.h / 2 - 5, initialVx, initialVy));
                        newWeaponAmmo = 0; // 蓄力射擊消耗所有彈藥
                        hasNewWeapon = false;
                        currentFireballs = maxFireballs; // 重置火球為滿，恢復普通武器
                    } else {
                        ultimateFireball=new UltimateFireball(this.x+this.w,0);
                        currentFireballs=0;
                    }
                }
            }
        }
        class Obstacle{constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h;}draw(){ctx.fillStyle='#d9534f';ctx.fillRect(this.x,this.y,this.w,this.h);}update(){this.x-=gameSpeed;this.draw();}}
        class Creature{constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h;this.dx=-gameSpeed*0.7;this.dy=0;this.isJumping=false;this.jumpPower=-12;this.groundY=canvas.height-10;}draw(){ctx.fillStyle='#8a2be2';ctx.fillRect(this.x,this.y,this.w,this.h);}update(){this.x+=this.dx;if(this.isJumping){this.dy+=gravity;this.y+=this.dy;}if(this.y+this.h>this.groundY){this.y=this.groundY-this.h;this.dy=0;this.isJumping=false;}for(const o of obstacles){if(o.x-this.x<80&&o.x-this.x>0&&!this.isJumping){this.jump();break;}}this.draw();}jump(){if(!this.isJumping){this.isJumping=true;this.dy=this.jumpPower;}}}
        class EnemyBullet{constructor(x,y,vx,vy){this.x=x;this.y=y;this.w=4;this.h=10;this.vx=vx;this.vy=vy;}draw(){ctx.fillStyle='#ffeb3b';ctx.fillRect(this.x,this.y,this.w,this.h);}update(){this.x+=this.vx;this.y+=this.vy;this.draw();}}
        class FlyingEnemy{constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h;this.dx=-gameSpeed*0.5;this.dy=1;this.targetY=Math.random()*60+20;this.isDescending=true;this.shootTimer=0;this.shootDelay=30;}draw(){ctx.fillStyle='#f1c40f';ctx.fillRect(this.x,this.y,this.w,this.h);}update(){if(this.isDescending){this.y+=this.dy;if(this.y>=this.targetY){this.isDescending=false;}}this.x+=this.dx;if(!this.isDescending){this.shootTimer++;if(this.shootTimer>=this.shootDelay){this.shoot();this.shootTimer=0;}}this.draw();}shoot(){enemyBullets.push(new EnemyBullet(this.x+this.w/2,this.y+this.h,0,4));}}

        class Boss {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.health = maxBossHealth;
                this.shootTimer = 0;
                this.summonTimer = 0;
                this.isSummoning = false;
                this.summonSequenceCounter = 0;
                this.delayBetweenSummons = 15; // Frames between each creature spawn
            }

            draw() {
                ctx.fillStyle = 'darkred'; // Large red rectangle for the boss
                ctx.fillRect(this.x, this.y, this.w, this.h);

                // Draw health bar
                const barWidth = this.w * 0.8;
                const barHeight = 10;
                const barX = this.x + (this.w - barWidth) / 2;
                const barY = this.y - 20;
                ctx.strokeStyle = 'white';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = 'red';
                ctx.fillRect(barX, barY, barWidth * (this.health / maxBossHealth), barHeight);
            }

            update() {
                // Boss stays on the right side, so no movement logic here.
                this.draw();

                // Bullet attack
                this.shootTimer++;
                if (this.shootTimer >= bossShootInterval) {
                    this.shoot();
                    this.shootTimer = 0;
                }

                // Summon creatures attack
                if (!this.isSummoning) {
                    this.summonTimer++;
                    if (this.summonTimer >= bossSummonInterval) {
                        this.summonTimer = 0;
                        this.isSummoning = true;
                        this.summonSequenceCounter = 0;
                        console.log("Boss: Starting summon sequence."); // New log
                    }
                } else { // In summoning sequence
                    this.summonSequenceCounter++;
                    console.log("Boss: Summon sequence counter:", this.summonSequenceCounter, "Modulo result:", this.summonSequenceCounter % this.delayBetweenSummons, "Delay between summons:", this.delayBetweenSummons); // New log
                    if (this.summonSequenceCounter % this.delayBetweenSummons === 0) {
                        this.summonCreature();
                        console.log("Boss: Summoned creature. Count:", this.summonSequenceCounter / this.delayBetweenSummons); // New log
                        if (this.summonSequenceCounter / this.delayBetweenSummons >= bossMaxSummon) {
                            this.isSummoning = false; // End sequence
                            this.summonSequenceCounter = 0;
                            console.log("Boss: Ending summon sequence."); // New log
                        }
                    }
                }
            }

            shoot() {
                // Boss fires bullets at the player
                // For simplicity, let's make it fire EnemyBullet from its center towards dino's current position
                const bulletX = this.x + this.w / 2;
                const bulletY = this.y + this.h / 2;
                // Calculate direction towards dino
                const dirX = dino.x - bulletX;
                const dirY = dino.y - bulletY;
                const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                const speed = 5; // Speed of boss bullet
                enemyBullets.push(new EnemyBullet(bulletX, bulletY, (dirX / magnitude) * speed, (dirY / magnitude) * speed));
            }

            summonCreature() {
                // Summon a purple creature (Creature class already draws purple)
                const s = 30;
                // Spawn near the boss, but not on top of it
                creatures.push(new Creature(this.x - s - 10, canvas.height - s - 10, s, s));
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    bossActive = false; // Boss defeated
                    console.log("Boss: DEFEATED! bossActive set to false."); // New log
                    bossDefeatedCount++; // Increment defeated count
                    // Add score bonus for defeating boss
                    score += 5000;
                    scorePopups.push(new ScorePopup(this.x + this.w / 2, this.y + this.h / 2, '+5000 BOSS DEFEATED!'));
                    // Clear existing enemies/bullets for a clean win
                    creatures = [];
                    flyingEnemies = [];
                    enemyBullets = [];
                    obstacles = [];
                }
            }
        }

        class LightningMark {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.strikeTimer = 1.5 * 60; // 1.5 seconds * 60 frames/second
                this.struck = false; // Flag to ensure lightning strikes only once
                this.width = 30; // Width for exclamation mark and lightning area
                this.height = 30; // Height for exclamation mark
            }

            draw() {
                if (!this.struck) {
                    // Draw red exclamation mark
                    ctx.fillStyle = 'red';
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', this.x + this.width / 2, this.y + this.height);
                    ctx.textAlign = 'left'; // Reset
                }
            }

            update() {
                this.strikeTimer--;
                if (this.strikeTimer <= 0 && !this.struck) {
                    this.struck = true;
                    this.strike();
                }
            }

            strike() {
                // Draw lightning (simple vertical line for now)
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, 0); // Top of canvas
                ctx.lineTo(this.x + this.width / 2, canvas.height); // Bottom of canvas
                ctx.stroke();

                // Check for collision with dino
                if (dino.x < this.x + this.width &&
                    dino.x + dino.w > this.x &&
                    dino.y < canvas.height && // Lightning covers full height
                    dino.y + dino.h > 0) { // Lightning covers full height
                    handleDamage();
                }
            }
        }

        class RainParticle {
            constructor(x, y, speedY) {
                this.x = x;
                this.y = y;
                this.speedY = speedY;
                this.length = Math.random() * 10 + 5; // Random length for rain drop
                this.width = 1; // Thin line
            }

            update() {
                this.y += this.speedY;
                if (this.y > canvas.height) {
                    this.y = 0; // Loop back to top
                    this.x = Math.random() * canvas.width; // New random x
                }
            }

            draw() {
                ctx.strokeStyle = 'rgba(173, 216, 230, 0.3)'; // Light blue, semi-transparent
                ctx.lineWidth = this.width;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.length);
                ctx.stroke();
            }
        }

        class WeaponPickup {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.speed = 2; // Speed at which it falls
            }

            draw() {
                ctx.fillStyle = 'purple'; // Purple square for now
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = 'white';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('W', this.x + this.width / 2, this.y + this.height - 5); // 'W' for Weapon
                ctx.textAlign = 'left';
            }

            update() {
                this.y += this.speed;
                this.draw();
            }
        }

        class PurpleBall {
            constructor(x, y, initialVx, initialVy) {
                this.x = x;
                this.y = y;
                this.radius = 8;
                this.vx = initialVx;
                this.vy = initialVy;
                this.gravity = 0.3; // Gravity for the purple ball
                this.exploded = false;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 60;
                this.explosionDuration = 30; // Frames for explosion animation
                this.explosionFrame = 0;
            }

            draw() {
                if (!this.exploded) {
                    ctx.fillStyle = 'purple';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw explosion
                    ctx.fillStyle = `rgba(255, 165, 0, ${1 - (this.explosionFrame / this.explosionDuration)})`; // Orange, fading
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.explosionRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            update(creatures, flyingEnemies, obstacles, enemyBullets) { // Add parameters
                if (!this.exploded) {
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;

                    // Check collision with ground
                    if (this.y + this.radius > canvas.height - 10) {
                        this.y = canvas.height - 10 - this.radius;
                        this.exploded = true;
                        this.explosionFrame = 0;
                        // Play explosion sound or animation start
                    }

                    // New: Check collision with other game objects
                    const collidableObjects = [...creatures, ...flyingEnemies, ...obstacles, ...enemyBullets];
                    for (const obj of collidableObjects) {
                        // Simple AABB collision for now, assuming objects have x, y, w, h
                        // For PurpleBall (circle) and other objects (rectangles), this is an approximation.
                        // A more accurate check would be circle-rectangle collision.
                        // However, for simplicity and given the current game's collision style,
                        // we can use a basic distance check or AABB for initial impact.
                        // Let's use a simple AABB check for initial impact to trigger explosion.
                        if (this.x - this.radius < obj.x + obj.w &&
                            this.x + this.radius > obj.x &&
                            this.y - this.radius < obj.y + obj.h &&
                            this.y + this.radius > obj.y) {
                            this.exploded = true;
                            this.explosionFrame = 0;
                            break; // Explode on first hit
                        }
                    }

                } else {
                    this.explosionFrame++;
                    this.explosionRadius = this.maxExplosionRadius * (this.explosionFrame / this.explosionDuration);
                    if (this.explosionFrame >= this.explosionDuration) {
                        return true; // Indicate that it's done exploding
                    }
                }
                this.draw();
                return false; // Not done exploding
            }

            // Check collision with enemies during explosion
            checkExplosionCollision(enemies) {
                if (this.exploded && this.explosionFrame > 0 && this.explosionFrame < this.explosionDuration) {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const dist = Math.sqrt(Math.pow(this.x - (enemy.x + enemy.w / 2), 2) + Math.pow(this.y - (enemy.y + enemy.h / 2), 2));
                        if (dist < this.explosionRadius + Math.max(enemy.w, enemy.h) / 2) {
                            // Collision detected
                            score += 100; // Example score for explosion hit
                            scorePopups.push(new ScorePopup(enemy.x, enemy.y, '+100'));
                            enemies.splice(i, 1);
                        }
                    }
                }
            }
        }

        // --- 遊戲邏輯處理 ---
        function handleDamage(){
            console.log("Dino took damage! Current health:", dinoHealth);
            if(isInvincible) return;
            dinoHealth--;
            isInvincible = true;
            invincibilityCounter = 0;
            canvasContainer.classList.add('shake');
            setTimeout(() => canvasContainer.classList.remove('shake'), 500);
            if(dinoHealth <= 0){
                gameOver = true;
                console.log("Dino health reached 0. Game Over!");
            }
        }
        function lerpColor(a,b,am){const ar=a>>16,ag=a>>8&0xff,ab=a&0xff,br=b>>16,bg=b>>8&0xff,bb=b&0xff,rr=ar+am*(br-ar),rg=ag+am*(bg-ag),rb=ab+am*(bb-ab);return(rr<<16|rg<<8|rb|0).toString(16).padStart(6,'0').replace(/^/,'#');}
        function handleDayNightCycle(){
            timeInCycle++;
            let dur = isDay ? dayDuration : nightDuration;
            if (timeInCycle > dur) {
                if (transitionTime < transitionDuration) {
                    transitionTime++;
                    const sC=isDay?dayColors:nightColors,eC=isDay?nightColors:dayColors,f=transitionTime/transitionDuration;
                    currentColors.bg=lerpColor(parseInt(sC.bg.slice(1),16),parseInt(eC.bg.slice(1),16),f);
                    currentColors.fg=lerpColor(parseInt(sC.fg.slice(1),16),parseInt(eC.fg.slice(1),16),f);
                    currentColors.ground=lerpColor(parseInt(sC.ground.slice(1),16),parseInt(eC.ground.slice(1),16),f);
                } else {
                    isDay = !isDay;
                    timeInCycle = 0;
                    transitionTime = 0;
                }
            }
            document.body.style.backgroundColor = currentColors.bg;
            document.querySelector('h1').style.color = currentColors.fg;
            document.querySelector('p').style.color = currentColors.fg;
            canvas.style.borderColor = currentColors.ground;
        }
        function handleInvincibility(){if(isInvincible){invincibilityCounter++;if(invincibilityCounter>=invincibilityDuration){isInvincible=false;invincibilityCounter=0;}}}
                function handleFireballs(){
            for(let i=fireballs.length-1;i>=0;i--){
                const fireball = fireballs[i];
                let removeFireball = false;

                if (fireball instanceof PurpleBall) {
                    if (fireball.update(creatures, flyingEnemies, obstacles, enemyBullets)) { // Pass arrays
                        removeFireball = true;
                    }
                    // 檢查爆炸碰撞
                    fireball.checkExplosionCollision(creatures);
                    fireball.checkExplosionCollision(flyingEnemies);
                    fireball.checkExplosionCollision(obstacles); // PurpleBall也可以摧毀障礙物
                    fireball.checkExplosionCollision(enemyBullets);
                    // New: Check collision with boss
                    if (bossActive && boss && fireball.exploded && fireball.explosionFrame > 0 && fireball.explosionFrame < fireball.explosionDuration) {
                        const dist = Math.sqrt(Math.pow(fireball.x - (boss.x + boss.w / 2), 2) + Math.pow(fireball.y - (boss.y + boss.h / 2), 2));
                        if (dist < fireball.explosionRadius + Math.max(boss.w, boss.h) / 2) {
                            boss.takeDamage(1); // PurpleBall explosion deals 1 damage
                            scorePopups.push(new ScorePopup(boss.x + boss.w / 2, boss.y + boss.h / 2, '-1 BOSS HP'));
                        }
                    }
                } else { // 普通火球
                    fireball.update();
                    // 現有的火球碰撞邏輯
                    for(let j=creatures.length-1;j>=0;j--){
                        if(fireball.x<creatures[j].x+creatures[j].w&&fireball.x+fireball.width>creatures[j].x&&fireball.y<creatures[j].y+creatures[j].h&&fireball.y+fireball.height>creatures[j].y){
                            const c=creatures[j];scorePopups.push(new ScorePopup(c.x,c.y,'+100'));creatures.splice(j,1);removeFireball=true;score+=100;break;
                        }
                    }
                    if (!removeFireball) { // 只有在尚未移除的情況下才檢查飛行敵人
                        for(let k=flyingEnemies.length-1;k>=0;k--){
                            if(fireball.x<flyingEnemies[k].x+flyingEnemies[k].w&&fireball.x+fireball.width>flyingEnemies[k].x&&fireball.y<flyingEnemies[k].y+flyingEnemies[k].h&&fireball.y+fireball.height>flyingEnemies[k].y){
                                const fe=flyingEnemies[k];scorePopups.push(new ScorePopup(fe.x,fe.y,'+150'));flyingEnemies.splice(k,1);removeFireball=true;score+=150;break;
                            }
                        }
                    }
                    // New: Check collision with boss for regular fireball
                    if (bossActive && boss && fireball.x < boss.x + boss.w && fireball.x + fireball.width > boss.x && fireball.y < boss.y + boss.h && fireball.y + fireball.height > boss.y) {
                        boss.takeDamage(1); // Regular fireball deals 1 damage
                        scorePopups.push(new ScorePopup(boss.x + boss.w / 2, boss.y + boss.h / 2, '-1 BOSS HP'));
                        removeFireball = true; // Remove fireball after hitting boss
                    }
                    if(fireball.x>canvas.width){removeFireball=true;}
                }

                if (removeFireball) {
                    fireballs.splice(i,1);
                }
            }
        }
        function handleUltimateFireball(){
            if(!ultimateFireball)return;
            ultimateFireball.update();
            const uf=ultimateFireball;
            [obstacles,creatures,flyingEnemies,enemyBullets].forEach(arr=>{
                for(let i=arr.length-1;i>=0;i--){
                    const item=arr[i];
                    // If boss is active, ultimate fireball does not affect boss
                    if (bossActive && boss && item === boss) {
                        continue; // Skip boss
                    }
                    if(uf.x<item.x+item.w&&uf.x+uf.w>item.x&&uf.y<item.y+item.h&&uf.y+uf.h>item.y){
                        // 增加分數並顯示分數彈窗
                        score += 200;
                        scorePopups.push(new ScorePopup(item.x, item.y, '+200'));
                        arr.splice(i,1);
                    }
                }
            });
            if(uf.x>canvas.width){ultimateFireball=null;}
        }
        function handleScorePopups(){for(let i=scorePopups.length-1;i>=0;i--){scorePopups[i].update();scorePopups[i].draw();if(scorePopups[i].life<=0){scorePopups.splice(i,1);}}}
        function handleFireballRegen(){if(currentFireballs<maxFireballs){fireballRegenCounter++;if(fireballRegenCounter>=fireballRegenRate){currentFireballs++;fireballRegenCounter=0;}}}
        function handleObstacles(){
            if (!bossActive && frameCount > nextObstacleFrame){ // Only spawn if no boss
                createObstacle();
                setNextObstacleFrame();
            }
            for(let i=obstacles.length-1;i>=0;i--){obstacles[i].update();if(dino.x<obstacles[i].x+obstacles[i].w&&dino.x+dino.w>obstacles[i].x&&dino.y<obstacles[i].y+obstacles[i].h&&dino.y+dino.h>obstacles[i].y){handleDamage();obstacles.splice(i,1);}}}
        function handleCreatures(){
            if (!bossActive && frameCount > nextCreatureFrame){ // Only spawn if no boss
                createCreature();
                setNextCreatureFrame();
            }
            for(let i=creatures.length-1;i>=0;i--){creatures[i].update();if(dino.x<creatures[i].x+creatures[i].w&&dino.x+dino.w>creatures[i].x&&dino.y<creatures[i].y+creatures[i].h&&dino.y+dino.h>creatures[i].y){handleDamage();creatures.splice(i,1);}}}
        function handleFlyingEnemies(){
            if (!bossActive && !isDay && frameCount > nextFlyingEnemySpawn) { // Only spawn if no boss
                createFlyingEnemy();
                nextFlyingEnemySpawn = frameCount + Math.floor(Math.random() * 120 + 100);
            }
            for(let i=flyingEnemies.length-1;i>=0;i--){flyingEnemies[i].update();if(dino.x<flyingEnemies[i].x+flyingEnemies[i].w&&dino.x+dino.w>flyingEnemies[i].x&&dino.y<flyingEnemies[i].y+flyingEnemies[i].h&&dino.y+dino.h>flyingEnemies[i].y){handleDamage();flyingEnemies.splice(i,1);}if(flyingEnemies[i]&&flyingEnemies[i].x+flyingEnemies[i].w<0){flyingEnemies.splice(i,1);}}}
        function handleEnemyBullets(){for(let i=enemyBullets.length-1;i>=0;i--){enemyBullets[i].update();if(dino.x<enemyBullets[i].x+enemyBullets[i].w&&dino.x+dino.w>enemyBullets[i].x&&dino.y<enemyBullets[i].y+enemyBullets[i].h&&dino.y+dino.h>enemyBullets[i].y){handleDamage();enemyBullets.splice(i,1);}if(enemyBullets[i]&&enemyBullets[i].y>canvas.height){enemyBullets.splice(i,1);}}}
        function createObstacle(){const h=Math.random()*30+20;obstacles.push(new Obstacle(canvas.width,canvas.height-h-10,20,h));}
        function createCreature(){const s=30;creatures.push(new Creature(canvas.width,canvas.height-s-10,s,s));}
        function createFlyingEnemy(){const s=35;flyingEnemies.push(new FlyingEnemy(canvas.width,-s,s,20));}

        // --- 繪圖與主迴圈 ---
        function drawChargeIndicator(){
            // 如果X鍵沒有被按下，或者火球能量不滿，或者沒有記錄按下時間，則不顯示蓄力條
            if (!keyState['KeyX'] || currentFireballs !== maxFireballs || xPressStartTime === 0) {
                return;
            }

            const barW=dino.w,barH=5,x=dino.x,y=dino.y-10;
            
            // 根據X鍵按下的時間來計算當前蓄力進度
            const currentChargeProgress = frameCount - xPressStartTime;
            const fillW=(currentChargeProgress/minChargeTime)*barW;

            ctx.fillStyle='#00bfff';
            ctx.fillRect(x,y,Math.min(fillW,barW),barH);
        }
        function drawHealth(){ctx.fillStyle='#d9534f';ctx.font='24px Arial';let hStr='';for(let i=0;i<dinoHealth;i++){hStr+='♥';}ctx.textAlign='right';ctx.fillText(hStr,canvas.width-10,30);ctx.textAlign='left';}
        function drawInfo(){ctx.fillStyle=currentColors.fg;ctx.font='20px Arial';ctx.fillText(`分數: ${score}`,10,30);}
        function drawFireballBar(){
            const bW=150,bH=15,x=10,y=40;
            ctx.strokeStyle=currentColors.ground;
            ctx.strokeRect(x,y,bW,bH);

            let fillW;
            let ammoText;
            let barColor;

            if (hasNewWeapon) {
                fillW = (newWeaponAmmo / newWeaponMaxAmmo) * bW;
                ammoText = `${newWeaponAmmo}/${newWeaponMaxAmmo}`;
                barColor = 'purple';
            } else {
                fillW = (currentFireballs / maxFireballs) * bW;
                ammoText = `${currentFireballs}/${maxFireballs}`;
                barColor = '#ff8c00'; // 原始橙色
            }

            ctx.fillStyle=barColor;
            ctx.fillRect(x,y,fillW,bH);
            ctx.fillStyle=currentColors.bg;
            ctx.font='12px Arial';
            ctx.textAlign='center';
            ctx.fillText(ammoText,x+bW/2,y+bH-3);
            ctx.textAlign='left';
        }
        function drawGround(){ctx.beginPath();ctx.moveTo(0,canvas.height-10);ctx.lineTo(canvas.width,canvas.height-10);ctx.strokeStyle=currentColors.ground;ctx.lineWidth=2;ctx.stroke();}

        function animate(){
            console.log("animate loop running. gameOver:", gameOver, "dinoHealth:", dinoHealth, "frameCount:", frameCount);
            if(gameOver){
                console.log("Game Over detected. Stopping animation.");
                showGameOver();
                window.addEventListener('keydown',resetOnGameOver,{once:true});
                return;
            }
            requestAnimationFrame(animate);
            if (keyState['KeyX'] && currentFireballs === maxFireballs && !isCharging && xPressStartTime > 0) {
                // 如果X鍵被按住，火球已滿，尚未蓄力，且按下時間已記錄
                if (frameCount - xPressStartTime >= minChargeTime) {
                    isCharging = true; // 開始蓄力
                    chargeTime = frameCount - xPressStartTime; // 初始化蓄力時間
                }
            }
            if(isCharging){
                chargeTime++;
                console.log("Charging: chargeTime =", chargeTime);
            }
            ctx.clearRect(0,0,canvas.width,canvas.height);

            handleDayNightCycle();
            handleInvincibility();
            drawGround();
            dino.update();
            handleFireballs();
            handleUltimateFireball();

            // BOSS 系統
            if (score >= 5000 && !bossActive && bossDefeatedCount === 0) {
                bossActive = true;
                // Boss appears on the far right, large size
                boss = new Boss(canvas.width - 150, canvas.height - 200, 150, 150); // x, y, w, h
                bossHealth = maxBossHealth; // Reset boss health
                // Clear existing enemies/obstacles to focus on boss
                obstacles = [];
                creatures = [];
                flyingEnemies = [];
                enemyBullets = [];
            }

            // Always handle all types of enemies/obstacles, but their spawning is now conditional
            handleObstacles();
            handleCreatures();
            handleFlyingEnemies();
            handleEnemyBullets(); // This handles all enemy bullets, including boss's and flying enemies'

            if (bossActive) {
                boss.update();
            } else {
                // No log here, as it's the default state
            }

            // 雷雨系統
            if (score >= 2000 && !thunderstormActive) {
                thunderstormActive = true;
                thunderstormStartTime = frameCount;
                lightningStrikeTimer = 0; // 重置以進行第一次打雷
                currentColors = { ...thunderstormColors }; // 設定為雷雨顏色
            }

            if (thunderstormActive) {
                // 檢查雷雨持續時間是否結束
                if (frameCount - thunderstormStartTime >= thunderstormDuration) {
                    thunderstormActive = false;
                    currentColors = isDay ? { ...dayColors } : { ...nightColors }; // 恢復顏色
                    rainParticles = []; // 清除雨滴粒子
                } else {
                    // 處理雷雨期間的閃電
                    lightningStrikeTimer++;
                    if (lightningStrikeTimer >= lightningStrikeInterval) {
                        const randomX = Math.random() * (canvas.width - 30);
                        lightningMarks.push(new LightningMark(randomX, 0));
                        lightningStrikeTimer = 0;
                    }

                    // 生成雨滴粒子
                    if (frameCount % 2 === 0) { // 每2幀生成一個新粒子
                        const randomX = Math.random() * canvas.width;
                        const randomSpeed = Math.random() * 5 + 2; // 速度介於2到7之間
                        rainParticles.push(new RainParticle(randomX, 0, randomSpeed));
                    }

                    // 更新和繪製雨滴粒子
                    for (let i = rainParticles.length - 1; i >= 0; i--) {
                        rainParticles[i].update();
                        rainParticles[i].draw();
                    }
                }
            } else {
                // 確保雷雨不活躍時清除雨滴粒子
                if (rainParticles.length > 0) {
                    rainParticles = [];
                }
            }

            // 更新和繪製閃電標記，移除已擊中的
            for (let i = lightningMarks.length - 1; i >= 0; i--) {
                lightningMarks[i].update();
                lightningMarks[i].draw();
                // 移除已擊中且不再可見的標記（例如，擊中後幾幀）
                if (lightningMarks[i].struck && lightningMarks[i].strikeTimer < -30) { // 閃電擊中後保持可見30幀
                    lightningMarks.splice(i, 1);
                }
            }

            // 武器掉落系統
            weaponDropTimer++;
            if (weaponDropTimer >= weaponDropInterval) {
                const randomX = Math.random() * (canvas.width - 25); // 25是掉落物的寬度
                weaponPickups.push(new WeaponPickup(randomX, -25)); // 從畫布上方開始
                weaponDropTimer = 0;
            }

            for (let i = weaponPickups.length - 1; i >= 0; i--) {
                const pickup = weaponPickups[i];
                pickup.update();

                // 檢查與恐龍的碰撞
                if (dino.x < pickup.x + pickup.width &&
                    dino.x + dino.w > pickup.x &&
                    dino.y < pickup.y + pickup.height &&
                    dino.y + dino.h > pickup.y) {
                    
                    hasNewWeapon = true;
                    newWeaponAmmo = newWeaponMaxAmmo;
                    weaponPickups.splice(i, 1); // 移除掉落物
                    // 可選：為拾取添加分數彈窗或音效
                } else if (pickup.y > canvas.height) {
                    // 如果掉落物掉出螢幕，則移除
                    weaponPickups.splice(i, 1);
                }
            }

            handleFireballRegen();
            handleScorePopups();
            drawInfo();
            drawFireballBar();
            drawHealth();
            drawChargeIndicator();
            score++;
            frameCount++;
            if(frameCount%200===0){gameSpeed+=0.2;}
        }

        // --- 遊戲狀態 ---
        function resetGame(){
            console.log("Resetting game...");
            dino=new Dino(50,canvas.height-50,40,40);
            obstacles=[];fireballs=[];creatures=[];scorePopups=[];flyingEnemies=[];enemyBullets=[];ultimateFireball=null;
            score=0;gameSpeed=5;gameOver=false;gameStarted=true;frameCount=0;
            currentFireballs=maxFireballs;fireballRegenCounter=0;
            dinoHealth=maxHealth;isInvincible=false;invincibilityCounter=0;
            isCharging=false;chargeTime=0;
            isDay=true;timeInCycle=0;transitionTime=0;currentColors={...dayColors};
            nextFlyingEnemySpawn = 0;

            // 重置雷雨系統變數
            thunderstormActive = false;
            thunderstormStartTime = 0;
            lightningStrikeTimer = 0;
            lightningMarks = [];
            rainParticles = [];

            // 重置新武器系統變數
            hasNewWeapon = false;
            newWeaponAmmo = 0;
            weaponDropTimer = 0;
            weaponPickups = [];

            // 重置BOSS系統變數
            boss = null;
            bossActive = false;
            bossHealth = maxBossHealth;
            bossShootTimer = 0;
            bossSummonTimer = 0;
            bossDefeatedCount = 0;

            setNextObstacleFrame();
            setNextCreatureFrame();
            animate();
            console.log("Game reset complete. Starting animation.");
        }

        function showGameOver(){ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.font='40px Arial';ctx.textAlign='center';ctx.fillText('遊戲結束',canvas.width/2,canvas.height/2-20);ctx.font='20px Arial';ctx.fillText(`你的分數: ${score}`,canvas.width/2,canvas.height/2+20);ctx.fillText('按任意鍵重新開始',canvas.width/2,canvas.height/2+60);ctx.textAlign='left';}
        function showStartScreen(){ctx.clearRect(0,0,canvas.width,canvas.height);drawGround();dino.draw();drawFireballBar();drawHealth();ctx.fillStyle=currentColors.fg;ctx.font='30px Arial';ctx.textAlign='center';ctx.fillText('準備好了嗎?',canvas.width/2,canvas.height/2-20);ctx.textAlign='left';}
        
        // --- 事件監聽 ---
        window.addEventListener('keydown', (e) => {
            const k = e.code;
            keyState[k] = true;
            if (k === 'Space' || k === 'ArrowUp') {
                e.preventDefault();
                if (!gameStarted) resetGame();
                else if (!gameOver) dino.jump();
            } else if (k === 'KeyX') {
                if (gameStarted && !gameOver) {
                    if (currentFireballs === maxFireballs) {
                        // 如果火球已滿，記錄按下時間，不立即射擊或蓄力
                        if (xPressStartTime === 0) { // 避免重複記錄
                            xPressStartTime = frameCount;
                        }
                    } else {
                        // 如果火球未滿，立即發射普通子彈
                        dino.shoot();
                    }
                }
            } else if (k === 'KeyP') { // New: Hidden key for adding points
                if (!gameOver) {
                    score += 5000;
                    scorePopups.push(new ScorePopup(dino.x, dino.y, '+5000 (DEBUG)'));
                    console.log("DEBUG: Added 5000 points. Current score:", score);
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const k = e.code;
            keyState[k] = false;
            if (k === 'Space' || k === 'ArrowUp') {
                if (gameStarted && !gameOver) dino.cutJump();
            }
            if (k === 'KeyX') {
                if (isCharging) {
                    dino.fireUltimate();
                    isCharging = false;
                    chargeTime = 0;
                } else if (xPressStartTime > 0 && currentFireballs === maxFireballs) {
                    // 如果是短按（不足以觸發蓄力），且火球已滿，則發射普通子彈
                    dino.shoot();
                }
                xPressStartTime = 0; // 重置 xPressStartTime
            }
        });

        function resetOnGameOver(e){if(gameOver)resetGame();}

        dinoImage.onload=()=>{dino=new Dino(50,canvas.height-50,40,40);showStartScreen();};
    </script>

</body>
</html>